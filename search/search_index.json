{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to Cloud Migration This tutorial is designed to show you with a concrete example how to perform a migration to the public cloud. In this tutorial, we will migrate a simple CRUD (Create, Read, Update, Delete) application progressively to the cloud, leveraging more and more on different managed services the further we go. Throughout the tutorial, the functionality of the application will not change, it will just become more reliable and less costly. This tutorial guides you through the following steps: Manually deploy an application on EC2 Instances Automatically deploy an application on EC2 Instances Make use of a managed database service Containerize an application and you a container service Use a managed runtime environment and make the application serverless","title":"Introduction"},{"location":"#introduction-to-cloud-migration","text":"This tutorial is designed to show you with a concrete example how to perform a migration to the public cloud. In this tutorial, we will migrate a simple CRUD (Create, Read, Update, Delete) application progressively to the cloud, leveraging more and more on different managed services the further we go. Throughout the tutorial, the functionality of the application will not change, it will just become more reliable and less costly. This tutorial guides you through the following steps: Manually deploy an application on EC2 Instances Automatically deploy an application on EC2 Instances Make use of a managed database service Containerize an application and you a container service Use a managed runtime environment and make the application serverless","title":"Introduction to Cloud Migration"},{"location":"cicd_artifacts/","text":"Continuous Integration and Delivery In an enterprise context, it's normally not one person doing the build, test and deploy steps for an application. You rather rely on an automated system which gives you clear visibility on who did when which change. In this lab, we will not build a very advanced CI/CD system as you have a dedicated course for that, but we will try to focus on a MVP (minimum viable product) configuration. At the end of this lab, every commit to the master branch of your repository should result in a build process to start. Step-by-Step instructions Create a Repository on github.com in which you will store your application source code your infrastructure source code Build artifact Upload to S3 Deploy with CloudFormation API","title":"Deploy through a CI/CD Pipeline"},{"location":"cicd_artifacts/#continuous-integration-and-delivery","text":"In an enterprise context, it's normally not one person doing the build, test and deploy steps for an application. You rather rely on an automated system which gives you clear visibility on who did when which change. In this lab, we will not build a very advanced CI/CD system as you have a dedicated course for that, but we will try to focus on a MVP (minimum viable product) configuration. At the end of this lab, every commit to the master branch of your repository should result in a build process to start.","title":"Continuous Integration and Delivery"},{"location":"cicd_artifacts/#step-by-step-instructions","text":"Create a Repository on github.com in which you will store your application source code your infrastructure source code Build artifact Upload to S3 Deploy with CloudFormation API","title":"Step-by-Step instructions"},{"location":"docker/","text":"Containerisation In this tutorial, we would like to make our application easily transferable between different cloud providers. As you have learned throughout the course, containerisation is a good way to achieve that goal. In this tutorial, we will add a Dockerfile to our repository and push it to docker.io. This enables us to have our artifacts stored in a \"neutral\" place, which can be used by various cloud providers. Once this is done, we will address the deployment of container through ECS, the Container service of AWS.","title":"Port your application to Docker"},{"location":"docker/#containerisation","text":"In this tutorial, we would like to make our application easily transferable between different cloud providers. As you have learned throughout the course, containerisation is a good way to achieve that goal. In this tutorial, we will add a Dockerfile to our repository and push it to docker.io. This enables us to have our artifacts stored in a \"neutral\" place, which can be used by various cloud providers. Once this is done, we will address the deployment of container through ECS, the Container service of AWS.","title":"Containerisation"},{"location":"iaas/","text":"Infrastructure as a Service In this first exercise, we are building an application consisting out of two components: A web server that is containg a so called CRUD application (Create, Read, Update, Delete) A database server that is hosting the applications data Step-by-Step instructions Go to the AWS Console and deploy the follow CloudFormation Stack: cf-database.yaml Note the Private IP Address of the EC2 Instance you have just created. You will need it for the next step when you deploy your actual application. In CloudFormation Console, deploy now the stack for your application: cf-application.yaml This stack outputs a public IP Address. Open it in your browser and you should see your deployed application. Congratulations, you have now deployed our first application based on VM Instances. Follow up exercise Currently, the cf-application.yaml is deploying a single EC2 Instance. Your task is now to transform the EC2 Resource into a Launch Configuration . Afterwards, assign this Launch Configuration to an Autoscaling Group . Next steps You can now move to the next chapter, where we will automate the deployment of our application.","title":"Infrastructure as a Service"},{"location":"iaas/#infrastructure-as-a-service","text":"In this first exercise, we are building an application consisting out of two components: A web server that is containg a so called CRUD application (Create, Read, Update, Delete) A database server that is hosting the applications data","title":"Infrastructure as a Service"},{"location":"iaas/#step-by-step-instructions","text":"Go to the AWS Console and deploy the follow CloudFormation Stack: cf-database.yaml Note the Private IP Address of the EC2 Instance you have just created. You will need it for the next step when you deploy your actual application. In CloudFormation Console, deploy now the stack for your application: cf-application.yaml This stack outputs a public IP Address. Open it in your browser and you should see your deployed application. Congratulations, you have now deployed our first application based on VM Instances.","title":"Step-by-Step instructions"},{"location":"iaas/#follow-up-exercise","text":"Currently, the cf-application.yaml is deploying a single EC2 Instance. Your task is now to transform the EC2 Resource into a Launch Configuration . Afterwards, assign this Launch Configuration to an Autoscaling Group .","title":"Follow up exercise"},{"location":"iaas/#next-steps","text":"You can now move to the next chapter, where we will automate the deployment of our application.","title":"Next steps"},{"location":"iaas_w_aurora/","text":"IaaS with Aurora You realized now that it's a difficult task to build a CloudFormation for Database. Also, the example that you deployed in the previous exercise is highly unsecure (as it's accessible from everywhere) and also not very reliable (as there is only one instance). Luckily, AWS provides a service called RDS (Relational Database Service). As part of RDS, there is a product called Aurora Serverless. It's a database that is completely compatible with MySQL and brings all the advantages of Serverless technology, means less resources to manage for you. In this exercise we deploy now Aurora through CloudFormation and change the configuration of our Webserver to use the new database. In a real-world use case you would for sure migrate your existing data, but let's skip that for now. Step-by-Step instructions Go to the AWS Console and deploy the follow CloudFormation Stack: cf-aurora.yaml Update your cf-application.yaml stack from the previous exercise to connect to the Aurora instance. Delete the CloudFormation stack for your previous database. Congratulations, you have one EC2 instance less to manage! Also you get the following advantages: Transparent Scalability High availability Managed Backups You can now move to the next chapter, where we will see how we can make our application easier transferable.","title":"The first managed service, Aurora"},{"location":"iaas_w_aurora/#iaas-with-aurora","text":"You realized now that it's a difficult task to build a CloudFormation for Database. Also, the example that you deployed in the previous exercise is highly unsecure (as it's accessible from everywhere) and also not very reliable (as there is only one instance). Luckily, AWS provides a service called RDS (Relational Database Service). As part of RDS, there is a product called Aurora Serverless. It's a database that is completely compatible with MySQL and brings all the advantages of Serverless technology, means less resources to manage for you. In this exercise we deploy now Aurora through CloudFormation and change the configuration of our Webserver to use the new database. In a real-world use case you would for sure migrate your existing data, but let's skip that for now.","title":"IaaS with Aurora"},{"location":"iaas_w_aurora/#step-by-step-instructions","text":"Go to the AWS Console and deploy the follow CloudFormation Stack: cf-aurora.yaml Update your cf-application.yaml stack from the previous exercise to connect to the Aurora instance. Delete the CloudFormation stack for your previous database. Congratulations, you have one EC2 instance less to manage! Also you get the following advantages: Transparent Scalability High availability Managed Backups You can now move to the next chapter, where we will see how we can make our application easier transferable.","title":"Step-by-Step instructions"},{"location":"lambda/","text":"","title":"Port your application to Lambda"}]}